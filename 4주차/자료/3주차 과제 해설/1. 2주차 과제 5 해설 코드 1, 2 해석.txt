priority_queue(이하 pq)는 디폴트로 int를 내림차순, 혹은 오름차순으로 정렬합니다. (오름인지, 내림인지는 언어차이)

정렬은 배열 속 데이터에 대해 미리 정해진 대소비교 로직으로 정렬하겠죠?
int는 너무 당연하게도 대소비교할 수 있습니다.

하지만 이 문제에서 절댓값은 단순하게 대소비교할 수 없죠.
"절댓값이 작은걸 우선으로, 같다면 실제값이 작은걸로" 이 말을 pq가 혼자 이해하긴 힘들겁니다.
따라서 우리가 직접 대소비교 로직을 정의해야합니다.

대소비교 로직을 직접 정의하는 법은 크게 두가지가 있고,
이 과제의 목적이 두가지 표현 방법을 모두 배우는 것입니다.


1. pq 인스턴스 자체의 정렬 기준을 직접 정의
pq에 들어온 값을 AbsComparator라는 기준으로 비교 로직을 정의하는 것입니다.
해당 pq에 새롭게 들어온 int값은 pq의 비교로직에 의해
"절댓값이 작거나, 같더라도 실제값이 작은 값"이라면 더 우선순위가 높다 판단하고,
아니라면 더 작다고 판단하여 pq 내에서 정렬합니다.

2. 새로운 자료형을 정의하고, 해당 자료형의 비교 로직을 정의
새로운 자료형 Abs를 정의한 후, Abs와 Abs 간의 대소를 비교하는 로직을 정의하는 방식입니다.
pq는 해당 Abs 내의 대소비교 로직을 이용하여 Abs 간의 우선순위를 정해 정렬합니다.


이제 두가지 방식이 좋은 상황을 알아봅시다.
1) 기본 자료형을 사용할 때
int, double, string과 같은 기본 자료형(string이 기본?)의 비교로직을 변경하고 싶을 떈, 1번 방식을 사용하면 됩니다.
pq를 선언할 때, 비교 로직을 정의해주면
새로운 클래스를 만들고, 인자 하나짜리 생성자를 정의하고, 객체 인스턴스를 만드는 등의
귀찮은 짓을 하지 않고 기본 자료형을 바로바로 사용할 수 있습니다.

2) 직접 정의한 자료형을 사용할 때
자신이 직접 정의한 자료형(이하 구조체)는 어차피 구조체 인스턴스를 생성해야만 합니다.
그렇기에 2번 방식을 사용하여 구조체에 대소비교 로직을 작성해주면
pq내에서 뿐만 아니라 다른 곳에서 광역적으로 쓸 수 있게 됩니다.